<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>MoveNet 자세 분석 AI</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f0f0f0;
    }
    .container {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }
    .video-container {
      position: relative;
    }
    #video {
      border: 2px solid #333;
      border-radius: 10px;
    }
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      border: 2px solid #ff0000;
      border-radius: 10px;
    }
    .info {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      min-width: 300px;
    }
    .status {
      padding: 10px;
      margin: 10px 0;
      border-radius: 5px;
      font-weight: bold;
    }
    .loading { background-color: #fff3cd; color: #856404; }
    .success { background-color: #d4edda; color: #155724; }
    .error { background-color: #f8d7da; color: #721c24; }
  </style>
</head>
<body>
  <h1>MoveNet 자세 분석 AI</h1>
  
  <div class="container">
    <div class="video-container">
      <video id="video" width="640" height="480" autoplay muted playsinline></video>
      <canvas id="canvas" width="640" height="480"></canvas>
    </div>
    
    <div class="info">
      <h3>상태 정보</h3>
      <div id="status" class="status loading">모델 로딩 중...</div>
      <div id="fps">FPS: 0</div>
      <div id="keypoints">감지된 키포인트: 0</div>
      <div id="model-info">모델 정보: 로딩 중...</div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script>
    let model = null;
    let isRunning = false;
    let frameCount = 0;
    let lastTime = Date.now();

    function updateStatus(message, type = 'loading') {
      const statusEl = document.getElementById('status');
      statusEl.textContent = message;
      statusEl.className = `status ${type}`;
    }

    function updateFPS() {
      const now = Date.now();
      const fps = Math.round(1000 / (now - lastTime));
      document.getElementById('fps').textContent = `FPS: ${fps}`;
      lastTime = now;
    }

    async function loadModel() {
      try {
        updateStatus("모델 로딩 중...", 'loading');
        console.log("모델 로딩 시작...");
        
        // model.json 이 있는 경로
        model = await tf.loadGraphModel('./model.json');
        console.log("모델 로드 완료", model);
        
        // 모델 정보 표시
        const modelInfo = `입력: ${model.inputs[0].shape}, 출력: ${model.outputs.length}개`;
        document.getElementById('model-info').textContent = `모델 정보: ${modelInfo}`;
        
        updateStatus("모델 로드 완료!", 'success');
        return model;
      } catch (error) {
        console.error("모델 로드 실패:", error);
        updateStatus(`모델 로드 실패: ${error.message}`, 'error');
        throw error;
      }
    }

    async function run() {
      try {
        await loadModel();

        // 웹캠 연결
        updateStatus("웹캠 연결 중...", 'loading');
        const video = document.getElementById('video');
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            width: 640, 
            height: 480,
            facingMode: 'user'
          } 
        });
        video.srcObject = stream;
        
        await new Promise(r => {
          video.onloadedmetadata = () => {
            console.log("비디오 로드 완료");
            r();
          };
        });

        updateStatus("실시간 자세 분석 시작!", 'success');

        // 매 프레임 예측
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        isRunning = true;

        async function predict() {
          if (!isRunning) return;

          try {
            // 비디오 프레임을 캔버스에 그리기
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // 영상 프레임을 Tensor로 변환
            const input = tf.browser.fromPixels(video)
              .resizeBilinear([192, 192]) // MoveNet 입력 크기
              .expandDims(0)
              .div(255.0) // 정규화
              .mul(255) // 0-255 범위로 변환
              .toInt(); // int32로 변환

            // 모델 예측
            const predictions = await model.predict(input);
            const keypoints = await predictions.data();
            
            // 키포인트 그리기
            drawKeypoints(ctx, keypoints, 192, 192, canvas.width, canvas.height);
            
            // FPS 업데이트
            frameCount++;
            if (frameCount % 30 === 0) {
              updateFPS();
            }
            
            // 메모리 정리
            input.dispose();
            predictions.dispose();

          } catch (error) {
            console.error("예측 오류:", error);
          }

          requestAnimationFrame(predict);
        }

        predict();
      } catch (error) {
        console.error("실행 오류:", error);
        updateStatus(`실행 오류: ${error.message}`, 'error');
      }
    }

    function drawKeypoints(ctx, keypoints, modelWidth, modelHeight, canvasWidth, canvasHeight) {
      const scaleX = canvasWidth / modelWidth;
      const scaleY = canvasHeight / modelHeight;
      
      ctx.strokeStyle = '#00ff00';
      ctx.lineWidth = 2;
      ctx.fillStyle = '#ff0000';
      
      // 키포인트 그리기 (MoveNet은 17개 키포인트)
      for (let i = 0; i < 17; i++) {
        const x = keypoints[i * 3] * scaleX;
        const y = keypoints[i * 3 + 1] * scaleY;
        const confidence = keypoints[i * 3 + 2];
        
        if (confidence > 0.3) { // 신뢰도 임계값
          ctx.beginPath();
          ctx.arc(x, y, 5, 0, 2 * Math.PI);
          ctx.fill();
        }
      }
      
      // 키포인트 개수 업데이트
      const detectedPoints = Array.from({length: 17}, (_, i) => 
        keypoints[i * 3 + 2] > 0.3 ? 1 : 0
      ).reduce((a, b) => a + b, 0);
      
      document.getElementById('keypoints').textContent = `감지된 키포인트: ${detectedPoints}/17`;
    }

    // 페이지 로드 시 실행
    run();
  </script>
</body>
</html>
